# AI Assistant Instructions for JavaScript/TypeScript Development Container

## Environment Context
This code is running in a **Next.js T3 Stack development container** with:
- Node.js 18 LTS with pnpm, yarn, and npm
- TypeScript with strict type checking enabled
- Next.js 14 with App Router and Server Components
- PostgreSQL database with Prisma ORM
- Redis for caching and session storage
- tRPC for end-to-end type safety
- Tailwind CSS for styling
- NextAuth.js for authentication
- Docker environment with volume persistence
- Pre-configured testing framework (Jest + React Testing Library)

## Coding Standards & Conventions

### JavaScript/TypeScript Naming Conventions
- **Variables**: Use `camelCase` for all variable names
  ```typescript
  // Correct
  const userEmail = "user@example.com";
  const apiResponse = await fetch(url);
  const connectionString = "postgresql://...";
  
  // Incorrect
  const user_email = "user@example.com";
  const api_response = await fetch(url);
  ```

- **Functions**: Use `camelCase` for function names
  ```typescript
  // Correct
  function processUserData(userData: string): string {
    return userData.toLowerCase();
  }
  
  const validateEmailAddress = (emailAddress: string): boolean => {
    return emailAddress.includes("@");
  };
  
  // Incorrect
  function process_user_data(userData: string): string {
    return userData.toLowerCase();
  }
  ```

- **Components**: Use `PascalCase` for React components
  ```typescript
  // Correct
  const UserProfile = ({ userId }: { userId: string }) => {
    return <div>User: {userId}</div>;
  };
  
  // Component files should also be PascalCase
  // UserProfile.tsx, DatabaseConnection.tsx
  ```

- **Constants**: Use `UPPER_SNAKE_CASE`
  ```typescript
  const MAX_RETRY_ATTEMPTS = 3;
  const DEFAULT_API_TIMEOUT = 30000;
  const DATABASE_CONNECTION_POOL_SIZE = 10;
  ```

### Inline Comments for Problem-Solving Enhancement

**Always include inline comments that explain the logical flow and reasoning:**

```typescript
async function analyzeUserBehavior(userId: string) {
  // Fetch user session data from Redis cache for performance
  const sessionData = await redis.get(`session:${userId}`);
  
  if (!sessionData) {
    // Cache miss - fetch from database and populate cache
    const userSession = await prisma.session.findUnique({
      where: { userId },
      include: { user: true } // Include user data to avoid additional queries
    });
    
    // Cache for 1 hour to reduce database load
    await redis.setex(`session:${userId}`, 3600, JSON.stringify(userSession));
    return userSession;
  }
  
  // Parse cached session data back to object
  const parsedSession = JSON.parse(sessionData);
  
  // Check if session is still valid based on timestamp
  const sessionAge = Date.now() - new Date(parsedSession.createdAt).getTime();
  const sessionExpired = sessionAge > 24 * 60 * 60 * 1000; // 24 hours
  
  if (sessionExpired) {
    // Remove expired session from cache to prevent stale data
    await redis.del(`session:${userId}`);
    return null;
  }
  
  return parsedSession;
}
```

### Development Container Specific Guidelines

1. **Database Connections**: Use the pre-configured Prisma setup
   ```typescript
   // Container provides PostgreSQL at db:5432
   import { PrismaClient } from '@prisma/client';
   
   // Prisma client is configured for container environment
   const prisma = new PrismaClient({
     datasources: {
       db: {
         // Container's internal network connection
         url: process.env.DATABASE_URL // postgresql://postgres:postgres@db:5432/devdb
       }
     }
   });
   
   async function createDatabaseConnection() {
     try {
       // Test container database connectivity
       await prisma.$connect();
       console.log('Connected to container PostgreSQL instance');
       return prisma;
     } catch (connectionError) {
       console.error('Container database connection failed:', connectionError);
       throw connectionError;
     }
   }
   ```

2. **File System Operations**: Handle container volume mounts
   ```typescript
   import { promises as fs } from 'fs';
   import path from 'path';
   
   // Container workspace is mounted at /workspace
   const workspaceRoot = '/workspace';
   const uploadDirectory = path.join(workspaceRoot, 'uploads');
   
   async function saveFileToContainer(fileData: Buffer, fileName: string) {
     // Ensure upload directory exists in container filesystem
     await fs.mkdir(uploadDirectory, { recursive: true });
     
     // Create full path for file storage in persistent volume
     const filePath = path.join(uploadDirectory, fileName);
     
     try {
       // Write file to container's persistent volume
       await fs.writeFile(filePath, fileData);
       
       // Return path relative to workspace for client access
       return path.relative(workspaceRoot, filePath);
     } catch (writeError) {
       console.error('Failed to save file in container:', writeError);
       throw new Error('Container file system error');
     }
   }
   ```

3. **Environment Variable Management**:
   ```typescript
   import { z } from 'zod';
   
   // Define schema for container environment validation
   const containerEnvSchema = z.object({
     NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
     DATABASE_URL: z.string().url(),
     REDIS_URL: z.string().url().default('redis://redis:6379'),
     NEXTAUTH_SECRET: z.string().min(32),
     NEXTAUTH_URL: z.string().url(),
     // Container-specific ports and services
     PORT: z.string().default('3000'),
     CONTAINER_NAME: z.string().optional()
   });
   
   export function validateContainerEnvironment() {
     try {
       // Parse and validate environment variables available in container
       const env = containerEnvSchema.parse(process.env);
       console.log('Container environment validated successfully');
       return env;
     } catch (validationError) {
       console.error('Container environment validation failed:', validationError);
       throw new Error('Invalid container configuration');
     }
   }
   ```

## Next.js & T3 Stack Specific Guidelines

### API Routes with tRPC
```typescript
import { z } from 'zod';
import { createTRPCRouter, publicProcedure, protectedProcedure } from '../trpc';

export const userRouter = createTRPCRouter({
  getUserProfile: protectedProcedure
    .input(z.object({ userId: z.string() }))
    .query(async ({ ctx, input }) => {
      // Access container's database through Prisma context
      const userProfile = await ctx.prisma.user.findUnique({
        where: { id: input.userId },
        // Include related data to minimize database round trips
        include: {
          posts: { take: 10, orderBy: { createdAt: 'desc' } },
          profile: true
        }
      });
      
      if (!userProfile) {
        // Return structured error for client handling
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'User profile not found in container database'
        });
      }
      
      // Cache user data in Redis for subsequent requests
      await ctx.redis.setex(
        `user:${input.userId}`, 
        3600, // 1 hour cache
        JSON.stringify(userProfile)
      );
      
      return userProfile;
    }),
});
```

### React Components with Container Awareness
```typescript
'use client';

import { useEffect, useState } from 'react';
import { api } from '~/utils/api';

interface ContainerHealthProps {
  serviceName: string;
}

export function ContainerHealthIndicator({ serviceName }: ContainerHealthProps) {
  const [healthStatus, setHealthStatus] = useState<'healthy' | 'unhealthy' | 'checking'>('checking');
  
  // Check container service health status
  const { data: serviceHealth, isLoading } = api.container.checkServiceHealth.useQuery(
    { service: serviceName },
    {
      refetchInterval: 30000, // Check every 30 seconds
      retry: (failureCount, error) => {
        // Retry logic for container network issues
        if (failureCount < 3) {
          console.log(`Retrying container health check (attempt ${failureCount + 1})`);
          return true;
        }
        return false;
      }
    }
  );
  
  useEffect(() => {
    if (isLoading) {
      setHealthStatus('checking');
    } else if (serviceHealth?.healthy) {
      setHealthStatus('healthy');
    } else {
      setHealthStatus('unhealthy');
    }
  }, [serviceHealth, isLoading]);
  
  // Visual indicator for container service status
  const statusColors = {
    healthy: 'bg-green-500',
    unhealthy: 'bg-red-500',
    checking: 'bg-yellow-500'
  };
  
  return (
    <div className="flex items-center space-x-2">
      {/* Status indicator with Tailwind classes */}
      <div className={`h-3 w-3 rounded-full ${statusColors[healthStatus]}`} />
      <span className="text-sm font-medium">
        {serviceName}: {healthStatus}
      </span>
    </div>
  );
}
```

## Security & Performance in Container

### Authentication with NextAuth.js
```typescript
import NextAuth, { type NextAuthOptions } from 'next-auth';
import { PrismaAdapter } from '@next-auth/prisma-adapter';

export const authOptions: NextAuthOptions = {
  // Use Prisma adapter for container database persistence
  adapter: PrismaAdapter(prisma),
  
  providers: [
    // Configure OAuth providers for container environment
    GitHubProvider({
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!,
    }),
  ],
  
  session: {
    strategy: 'database', // Store sessions in container database
    maxAge: 24 * 60 * 60, // 24 hours
  },
  
  callbacks: {
    session: async ({ session, user }) => {
      // Attach user ID to session for container-wide access
      if (session.user) {
        session.user.id = user.id;
        
        // Cache session data in Redis for performance
        await redis.setex(
          `session:${user.id}`,
          3600, // 1 hour cache
          JSON.stringify(session)
        );
      }
      
      return session;
    },
  },
  
  // Container-specific configuration
  trustHost: true, // Trust container's internal network
  useSecureCookies: process.env.NODE_ENV === 'production',
};
```

### Error Handling with Container Context
```typescript
export class ContainerError extends Error {
  public readonly code: string;
  public readonly service: string;
  
  constructor(message: string, code: string, service: string) {
    super(message);
    this.name = 'ContainerError';
    this.code = code;
    this.service = service;
  }
}

export function handleContainerErrors(error: unknown, context: string) {
  console.error(`Container error in ${context}:`, error);
  
  if (error instanceof Error) {
    // Check for common container-related errors
    if (error.message.includes('ECONNREFUSED')) {
      throw new ContainerError(
        'Container service unavailable - check docker-compose services',
        'SERVICE_UNAVAILABLE',
        context
      );
    }
    
    if (error.message.includes('ENOTFOUND')) {
      throw new ContainerError(
        'Container network resolution failed - check service names',
        'NETWORK_ERROR',
        context
      );
    }
    
    if (error.message.includes('permission denied')) {
      throw new ContainerError(
        'Container permission error - check volume mounts and user permissions',
        'PERMISSION_ERROR',
        context
      );
    }
  }
  
  // Generic container error
  throw new ContainerError(
    'Unknown container error occurred',
    'UNKNOWN_ERROR',
    context
  );
}
```

## Testing in Container Environment

```typescript
import { render, screen } from '@testing-library/react';
import { createTRPCMsw } from 'msw-trpc';
import { setupServer } from 'msw/node';
import { type AppRouter } from '~/server/api/root';

// Mock server for testing container API interactions
const server = setupServer();

// Mock tRPC calls that would normally hit container services
const trpcMsw = createTRPCMsw<AppRouter>();

describe('Container Integration Tests', () => {
  beforeAll(() => {
    // Start mock server for container testing
    server.listen();
  });
  
  beforeEach(() => {
    // Mock container database responses
    server.use(
      trpcMsw.user.getUserProfile.query(() => ({
        id: 'test-user-id',
        email: 'test@container.local',
        name: 'Container Test User'
      }))
    );
  });
  
  afterEach(() => {
    server.resetHandlers();
  });
  
  afterAll(() => {
    server.close();
  });
  
  test('should handle container service connectivity', async () => {
    // Test component behavior when container services are available
    render(<UserProfile userId="test-user-id" />);
    
    // Verify component renders with container data
    expect(await screen.findByText('Container Test User')).toBeInTheDocument();
  });
  
  test('should gracefully handle container service failures', async () => {
    // Mock container service failure
    server.use(
      trpcMsw.user.getUserProfile.query(() => {
        throw new Error('Container database connection failed');
      })
    );
    
    render(<UserProfile userId="test-user-id" />);
    
    // Verify error handling for container issues
    expect(await screen.findByText(/error loading profile/i)).toBeInTheDocument();
  });
});
```

## Performance Optimization for Container

```typescript
import { NextRequest, NextResponse } from 'next/server';

export async function middleware(request: NextRequest) {
  // Optimize requests within container environment
  const start = Date.now();
  
  // Check Redis cache first to avoid database queries
  const cacheKey = `page:${request.nextUrl.pathname}`;
  const cachedResponse = await redis.get(cacheKey);
  
  if (cachedResponse) {
    // Return cached response to reduce container resource usage
    const response = new NextResponse(cachedResponse);
    response.headers.set('X-Cache', 'HIT');
    response.headers.set('X-Container-Response-Time', `${Date.now() - start}ms`);
    return response;
  }
  
  // Continue to Next.js rendering
  const response = NextResponse.next();
  
  // Add container performance headers for monitoring
  response.headers.set('X-Container-Response-Time', `${Date.now() - start}ms`);
  response.headers.set('X-Container-Name', process.env.CONTAINER_NAME || 'dev-container');
  
  return response;
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']
};
```

## Container Resource Monitoring

```typescript
import { NextApiRequest, NextApiResponse } from 'next';
import os from 'os';

interface ContainerMetrics {
  memory: {
    used: number;
    total: number;
    percentage: number;
  };
  cpu: {
    cores: number;
    load: number[];
  };
  uptime: number;
  containerInfo: {
    nodeVersion: string;
    platform: string;
    arch: string;
  };
}

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<ContainerMetrics>
) {
  try {
    // Gather container resource information
    const memoryUsage = process.memoryUsage();
    const totalMemory = os.totalmem();
    const usedMemory = memoryUsage.heapUsed + memoryUsage.external;
    
    const metrics: ContainerMetrics = {
      memory: {
        used: usedMemory,
        total: totalMemory,
        percentage: (usedMemory / totalMemory) * 100
      },
      cpu: {
        cores: os.cpus().length,
        load: os.loadavg()
      },
      uptime: process.uptime(),
      containerInfo: {
        nodeVersion: process.version,
        platform: os.platform(),
        arch: os.arch()
      }
    };
    
    // Cache metrics briefly to avoid overwhelming container resources
    await redis.setex('container:metrics', 30, JSON.stringify(metrics));
    
    res.status(200).json(metrics);
  } catch (error) {
    console.error('Failed to gather container metrics:', error);
    res.status(500).json({
      error: 'Container metrics unavailable'
    } as any);
  }
}
```

## Best Practices Summary

1. **Type Safety**: Leverage TypeScript strictly with Zod validation
2. **Performance**: Use Redis caching for container resource optimization
3. **Error Handling**: Implement container-aware error boundaries
4. **Testing**: Mock container services for reliable test environments
5. **Monitoring**: Track container resource usage and service health
6. **Security**: Validate all inputs and use secure container networking
7. **Database**: Utilize Prisma's type-safe database operations
8. **Caching**: Implement Redis caching for frequently accessed data

Remember: This T3 Stack container environment provides end-to-end type safety from database to frontend. Always leverage tRPC for API calls, Prisma for database operations, and consider container resource limits when implementing features. 